# HG changeset patch
# User Martin Thomson <martin.thomson@gmail.com>
# Date 1534483208 -36000
#      Fri Aug 17 15:20:08 2018 +1000
# Node ID 2ed9f6afd84eb7fd1033ffaf448655e1d5a79bb8
# Parent  91b6fb509cb01bbf4466f647cccfa2a2e060c504
Bug 1483128 - Option to disable SSLv2-compatible ClientHello, r=ueno

diff -r 91b6fb509cb0 -r 2ed9f6afd84e gtests/ssl_gtest/ssl_gather_unittest.cc
--- a/nss/gtests/ssl_gtest/ssl_gather_unittest.cc	Wed Aug 15 10:24:18 2018 +1000
+++ b/nss/gtests/ssl_gtest/ssl_gather_unittest.cc	Fri Aug 17 15:20:08 2018 +1000
@@ -15,6 +15,7 @@
 
   void ConnectExpectMalformedClientHello(const DataBuffer &data) {
     EnsureTlsSetup();
+    server_->SetOption(SSL_ENABLE_V2_COMPATIBLE_HELLO, PR_TRUE);
     server_->ExpectSendAlert(kTlsAlertIllegalParameter);
     client_->SendDirect(data);
     server_->StartConnect();
diff -r 91b6fb509cb0 -r 2ed9f6afd84e gtests/ssl_gtest/ssl_v2_client_hello_unittest.cc
--- a/nss/gtests/ssl_gtest/ssl_v2_client_hello_unittest.cc	Wed Aug 15 10:24:18 2018 +1000
+++ b/nss/gtests/ssl_gtest/ssl_v2_client_hello_unittest.cc	Fri Aug 17 15:20:08 2018 +1000
@@ -151,6 +151,7 @@
   void SetUp() override {
     TlsConnectTestBase::SetUp();
     filter_ = MakeTlsFilter<SSLv2ClientHelloFilter>(client_, version_);
+    server_->SetOption(SSL_ENABLE_V2_COMPATIBLE_HELLO, PR_TRUE);
   }
 
   void SetExpectedVersion(uint16_t version) {
@@ -197,6 +198,27 @@
   Connect();
 }
 
+TEST_P(SSLv2ClientHelloTest, ConnectDisabled) {
+  server_->SetOption(SSL_ENABLE_V2_COMPATIBLE_HELLO, PR_FALSE);
+  SetAvailableCipherSuite(TLS_DHE_RSA_WITH_AES_128_CBC_SHA);
+
+  StartConnect();
+  client_->Handshake();  // Send the modified ClientHello.
+  server_->Handshake();  // Read some.
+  // The problem here is that the v2 ClientHello puts the version where the v3
+  // ClientHello puts a version number.  So the version number (0x0301+) appears
+  // to be a length and server blocks waiting for that much data.
+  EXPECT_EQ(PR_WOULD_BLOCK_ERROR, PORT_GetError());
+
+  // This is usually what happens with v2-compatible: the server hangs.
+  // But to be certain, feed in more data to see if an error comes out.
+  uint8_t zeros[SSL_LIBRARY_VERSION_TLS_1_2] = {0};
+  client_->SendDirect(DataBuffer(zeros, sizeof(zeros)));
+  ExpectAlert(server_, kTlsAlertIllegalParameter);
+  server_->Handshake();
+  client_->Handshake();
+}
+
 // Sending a v2 ClientHello after a no-op v3 record must fail.
 TEST_P(SSLv2ClientHelloTest, ConnectAfterEmptyV3Record) {
   DataBuffer buffer;
diff -r 91b6fb509cb0 -r 2ed9f6afd84e lib/ssl/ssl.h
--- a/nss/lib/ssl/ssl.h	Wed Aug 15 10:24:18 2018 +1000
+++ b/nss/lib/ssl/ssl.h	Fri Aug 17 15:20:08 2018 +1000
@@ -282,6 +282,14 @@ SSL_IMPORT PRFileDesc *DTLS_ImportFD(PRF
  */
 #define SSL_ENABLE_DTLS_SHORT_HEADER 36
 
+/* Enables the SSLv2-compatible ClientHello for servers. NSS does not support
+ * SSLv2 and will never send an SSLv2-compatible ClientHello as a client.  An
+ * NSS server with this option enabled will accept a ClientHello that is
+ * v2-compatible as defined in Appendix E.1 of RFC 6101.
+ *
+ * This is disabled by default and will be removed in a future version. */
+#define SSL_ENABLE_V2_COMPATIBLE_HELLO 37
+
 #ifdef SSL_DEPRECATED_FUNCTION
 /* Old deprecated function names */
 SSL_IMPORT SECStatus SSL_Enable(PRFileDesc *fd, int option, PRIntn on);
diff -r 91b6fb509cb0 -r 2ed9f6afd84e lib/ssl/ssl3gthr.c
--- a/nss/lib/ssl/ssl3gthr.c	Wed Aug 15 10:24:18 2018 +1000
+++ b/nss/lib/ssl/ssl3gthr.c	Fri Aug 17 15:20:08 2018 +1000
@@ -470,8 +470,8 @@
             ssl2Gather ssl2gs = { PR_FALSE, 0 };
             ssl2Gather *ssl2gs_ptr = NULL;
 
-            /* If we're a server and waiting for a client hello, accept v2. */
-            if (ss->sec.isServer && ss->ssl3.hs.ws == wait_client_hello) {
+            if (ss->sec.isServer && ss->opt.enableV2CompatibleHello &&
+                ss->ssl3.hs.ws == wait_client_hello) {
                 ssl2gs_ptr = &ssl2gs;
             }
 
@@ -484,8 +484,8 @@
             }
 
             if (!IS_DTLS(ss)) {
-                /* If we're a server waiting for a ClientHello then pass
-                 * ssl2gs to support SSLv2 ClientHello messages. */
+                /* Passing a non-NULL ssl2gs here enables detection of
+                 * SSLv2-compatible ClientHello messages. */
                 rv = ssl3_GatherData(ss, &ss->gs, flags, ssl2gs_ptr);
             } else {
                 rv = dtls_GatherData(ss, &ss->gs, flags);
diff -r 91b6fb509cb0 -r 2ed9f6afd84e lib/ssl/sslimpl.h
--- a/nss/lib/ssl/sslimpl.h	Wed Aug 15 10:24:18 2018 +1000
+++ b/nss/lib/ssl/sslimpl.h	Fri Aug 17 15:20:08 2018 +1000
@@ -266,6 +266,7 @@ typedef struct sslOptionsStr {
     unsigned int enable0RttData : 1;
     unsigned int enableTls13CompatMode : 1;
     unsigned int enableDtlsShortHeader : 1;
+    unsigned int enableV2CompatibleHello : 1;
 } sslOptions;
 
 typedef enum { sslHandshakingUndetermined = 0,
diff -r 91b6fb509cb0 -r 2ed9f6afd84e lib/ssl/sslsock.c
--- a/nss/lib/ssl/sslsock.c	Wed Aug 15 10:24:18 2018 +1000
+++ b/nss/lib/ssl/sslsock.c	Fri Aug 17 15:20:08 2018 +1000
@@ -82,7 +82,8 @@ static sslOptions ssl_defaults = {
     .requireDHENamedGroups = PR_FALSE,
     .enable0RttData = PR_FALSE,
     .enableTls13CompatMode = PR_FALSE,
-    .enableDtlsShortHeader = PR_FALSE
+    .enableDtlsShortHeader = PR_FALSE,
+    .enableV2CompatibleHello = PR_FALSE
 };
 
 /*
@@ -821,6 +822,10 @@ SSL_OptionSet(PRFileDesc *fd, PRInt32 wh
             ss->opt.enableDtlsShortHeader = val;
             break;
 
+        case SSL_ENABLE_V2_COMPATIBLE_HELLO:
+            ss->opt.enableV2CompatibleHello = val;
+            break;
+
         default:
             PORT_SetError(SEC_ERROR_INVALID_ARGS);
             rv = SECFailure;
@@ -963,6 +968,9 @@ SSL_OptionGet(PRFileDesc *fd, PRInt32 wh
         case SSL_ENABLE_DTLS_SHORT_HEADER:
             val = ss->opt.enableDtlsShortHeader;
             break;
+        case SSL_ENABLE_V2_COMPATIBLE_HELLO:
+            val = ss->opt.enableV2CompatibleHello;
+            break;
         default:
             PORT_SetError(SEC_ERROR_INVALID_ARGS);
             rv = SECFailure;
@@ -1089,6 +1097,9 @@ SSL_OptionGetDefault(PRInt32 which, PRIn
         case SSL_ENABLE_DTLS_SHORT_HEADER:
             val = ssl_defaults.enableDtlsShortHeader;
             break;
+        case SSL_ENABLE_V2_COMPATIBLE_HELLO:
+            val = ssl_defaults.enableV2CompatibleHello;
+            break;
         default:
             PORT_SetError(SEC_ERROR_INVALID_ARGS);
             rv = SECFailure;
@@ -1284,6 +1295,10 @@ SSL_OptionSetDefault(PRInt32 which, PRIn
             ssl_defaults.enableDtlsShortHeader = val;
             break;
 
+        case SSL_ENABLE_V2_COMPATIBLE_HELLO:
+            ssl_defaults.enableV2CompatibleHello = val;
+            break;
+
         default:
             PORT_SetError(SEC_ERROR_INVALID_ARGS);
             return SECFailure;
